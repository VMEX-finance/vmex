"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function BlockUtils(ethers) {
    const { provider, BigNumber: BN, utils: { hexValue }, } = ethers;
    const isAutomine = () => {
        return provider.send('hardhat_getAutomine', []);
    };
    const setAutomine = (enabled) => {
        return provider.send('evm_setAutomine', [!!enabled]);
    };
    const setIntervalMining = (ms) => {
        if (BN.isBigNumber(ms)) {
            ms = ms.toNumber();
        }
        if (ms < 0) {
            throw Error(`Cannot set negative interval mining: ${ms}`);
        }
        return provider.send('evm_setIntervalMining', [ms]);
    };
    const latest = () => {
        return provider.getBlock('latest');
    };
    const latestBlockNumber = () => {
        return provider.getBlockNumber();
    };
    const advance = (n = 1, interval = 1) => {
        if (BN.isBigNumber(n)) {
            n = n.toNumber();
        }
        if (BN.isBigNumber(interval)) {
            interval = interval.toNumber();
        }
        if (n < 0) {
            throw Error(`Cannot advance negative blocks: ${n}`);
        }
        return provider.send('hardhat_mine', [hexValue(n), hexValue(interval)]);
    };
    const advanceTo = async (target, interval = 1) => {
        if (BN.isBigNumber(target)) {
            target = target.toNumber();
        }
        const latest = await latestBlockNumber();
        if (target <= latest) {
            throw Error(`Cannot advance to the block number ${target} which is not greater that current block number ${latest}`);
        }
        return advance(target - latest, interval);
    };
    return {
        isAutomine,
        setAutomine,
        latest,
        latestBlockNumber,
        advance,
        advanceTo,
        setIntervalMining,
    };
}
exports.default = BlockUtils;
//# sourceMappingURL=block.js.map