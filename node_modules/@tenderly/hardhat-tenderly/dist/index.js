"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReverseNetworkMap = exports.NetworkMap = exports.PluginName = void 0;
require("@nomiclabs/hardhat-ethers");
const config_1 = require("hardhat/config");
const plugins_1 = require("hardhat/plugins");
const Tenderly_1 = require("./Tenderly");
const TenderlyService_1 = require("./tenderly/TenderlyService");
require("./type-extensions");
const util_1 = require("./util");
exports.PluginName = "hardhat-tenderly";
config_1.extendEnvironment(env => {
    env.tenderly = plugins_1.lazyObject(() => new Tenderly_1.Tenderly(env));
    extendProvider(env);
});
config_1.extendConfig((resolvedConfig, userConfig) => {
    resolvedConfig.networks.tenderly = Object.assign({}, resolvedConfig.networks.tenderly);
});
const extendProvider = (hre) => {
    if (hre.network.name !== "tenderly") {
        return;
    }
    hre.tenderly
        .network()
        .initializeFork()
        .then(_ => {
        const provider = new hre.ethers.providers.Web3Provider(hre.tenderly.network());
        hre.ethers.provider = provider;
    })
        .catch(_ => {
        console.log(`Error in ${exports.PluginName}: Initializing fork, check your tenderly configuration`);
    });
};
exports.NetworkMap = {
    kovan: "42",
    goerli: "5",
    mainnet: "1",
    rinkeby: "4",
    ropsten: "3",
    matic: "137",
    mumbai: "80001",
    xdai: "100",
    poa: "99"
};
exports.ReverseNetworkMap = {
    "42": "kovan",
    "5": "goerli",
    "1": "mainnet",
    "4": "rinkeby",
    "3": "ropsten",
    "80001": "matic-mumbai",
    "137": "matic-mainnet",
    "100": "xdai",
    "99": "poa"
};
const extractContractData = async (contracts, network, config, run) => {
    let contract;
    const requestContracts = [];
    const sourcePaths = await run("compile:solidity:get-source-paths");
    const sourceNames = await run("compile:solidity:get-source-names", {
        sourcePaths
    });
    const data = await run("compile:solidity:get-dependency-graph", {
        sourceNames
    });
    const metadata = {
        compiler: {
            version: util_1.extractCompilerVersion(config)
        },
        sources: {}
    };
    data._resolvedFiles.forEach((resolvedFile, _) => {
        for (contract of contracts) {
            const contractData = contract.split("=");
            if (contractData.length < 2) {
                throw new plugins_1.HardhatPluginError(exports.PluginName, `Invalid contract provided`);
            }
            if (network === undefined) {
                throw new plugins_1.HardhatPluginError(exports.PluginName, `No network provided`);
            }
            const sourcePath = resolvedFile.sourceName;
            const name = sourcePath
                .split("/")
                .slice(-1)[0]
                .split(".")[0];
            if (name !== contractData[0]) {
                continue;
            }
            metadata.sources[sourcePath] = {
                content: resolvedFile.content.rawContent
            };
            const visited = {};
            util_1.resolveDependencies(data, sourcePath, metadata, visited);
        }
    });
    for (const [key, value] of Object.entries(metadata.sources)) {
        const name = key
            .split("/")
            .slice(-1)[0]
            .split(".")[0];
        const contractToPush = {
            contractName: name,
            source: value.content,
            sourcePath: key,
            networks: {},
            compiler: {
                name: "solc",
                version: util_1.extractCompilerVersion(config, key)
            }
        };
        for (contract of contracts) {
            const contractData = contract.split("=");
            if (contractToPush.contractName === contractData[0]) {
                contractToPush.networks = {
                    [exports.NetworkMap[network.toLowerCase()]]: {
                        address: contractData[1]
                    }
                };
            }
        }
        requestContracts.push(contractToPush);
    }
    return requestContracts;
};
const verifyContract = async ({ contracts }, { config, hardhatArguments, run }) => {
    if (contracts === undefined) {
        throw new plugins_1.HardhatPluginError(exports.PluginName, `At least one contract must be provided (ContractName=Address)`);
    }
    const requestContracts = await extractContractData(contracts, hardhatArguments.network, config, run);
    await TenderlyService_1.TenderlyService.verifyContracts({
        config: util_1.newCompilerConfig(config),
        contracts: requestContracts
    });
};
const pushContracts = async ({ contracts }, { config, hardhatArguments, run }) => {
    if (contracts === undefined) {
        throw new plugins_1.HardhatPluginError(exports.PluginName, `At least one contract must be provided (ContractName=Address)`);
    }
    if (config.tenderly.project === undefined) {
        throw new plugins_1.HardhatPluginError(exports.PluginName, `Please provide the project field in the tenderly object in hardhat.config.js`);
    }
    if (config.tenderly.username === undefined) {
        throw new plugins_1.HardhatPluginError(exports.PluginName, `Please provide the username field in the tenderly object in hardhat.config.js`);
    }
    const requestContracts = await extractContractData(contracts, hardhatArguments.network, config, run);
    const solcConfig = util_1.newCompilerConfig(config);
    await TenderlyService_1.TenderlyService.pushContracts({
        config: solcConfig,
        contracts: requestContracts
    }, config.tenderly.project, config.tenderly.username);
};
config_1.task("tenderly:verify", "Verifies contracts on Tenderly")
    .addOptionalVariadicPositionalParam("contracts", "Addresses and names of contracts that will be verified formatted ContractName=Address")
    .setAction(verifyContract);
config_1.task("tenderly:push", "Privately pushes contracts to Tenderly")
    .addOptionalVariadicPositionalParam("contracts", "Addresses and names of contracts that will be verified formatted ContractName=Address")
    .setAction(pushContracts);
//# sourceMappingURL=index.js.map