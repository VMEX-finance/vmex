"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefenderRelaySigner = void 0;
const strings_1 = require("@ethersproject/strings");
const abstract_signer_1 = require("@ethersproject/abstract-signer");
const bytes_1 = require("@ethersproject/bytes");
const bignumber_1 = require("@ethersproject/bignumber");
const logger_1 = require("@ethersproject/logger");
const hash_1 = require("@ethersproject/hash");
const properties_1 = require("@ethersproject/properties");
const relayer_1 = require("../relayer");
const lodash_1 = require("lodash");
const logger = new logger_1.Logger(`defender-relay-client`);
const allowedTransactionKeys = [
    'chainId',
    'data',
    'from',
    'gasLimit',
    'gasPrice',
    'maxFeePerGas',
    'maxPriorityFeePerGas',
    'nonce',
    'to',
    'value',
    'speed',
];
class DefenderRelaySigner extends abstract_signer_1.Signer {
    constructor(relayerCredentials, provider, options = {}) {
        super();
        this.relayerCredentials = relayerCredentials;
        this.provider = provider;
        this.options = options;
        this.relayer = relayer_1.isRelayer(relayerCredentials) ? relayerCredentials : new relayer_1.Relayer(relayerCredentials);
        if (options) {
            const getUnnecesaryExtraFields = (invalidFields) => invalidFields.map((field) => options[field]).filter(Boolean);
            if (options.speed) {
                const unnecesaryExtraFields = getUnnecesaryExtraFields(['maxFeePerGas', 'maxPriorityFeePerGas', 'gasPrice']);
                if (unnecesaryExtraFields.length > 0)
                    throw new Error(`Inconsistent options: speed + (${unnecesaryExtraFields}) not allowed`);
            }
            else if (options.gasPrice) {
                const unnecesaryExtraFields = getUnnecesaryExtraFields([
                    'maxFeePerGas',
                    'maxPriorityFeePerGas',
                ]);
                if (unnecesaryExtraFields.length > 0)
                    throw new Error(`Inconsistent options: gasPrice + (${unnecesaryExtraFields}) not allowed`);
            }
            else if (options.maxFeePerGas && options.maxPriorityFeePerGas) {
                if (options.maxFeePerGas < options.maxPriorityFeePerGas)
                    throw new Error('Inconsistent options: maxFeePerGas should be greater or equal to maxPriorityFeePerGas');
            }
            else if (options.maxFeePerGas)
                throw new Error('Inconsistent options: maxFeePerGas without maxPriorityFeePerGas specified');
            else if (options.maxPriorityFeePerGas)
                throw new Error('Inconsistent options: maxPriorityFeePerGas without maxFeePerGas specified');
        }
    }
    async getAddress() {
        // cache value because it does not change
        if (!this.address) {
            const r = await this.relayer.getRelayer();
            this.address = r.address;
        }
        return this.address;
    }
    // Returns the signed prefixed-message. This MUST treat:
    // - Bytes as a binary message
    // - string as a UTF8-message
    // i.e. "0x1234" is a SIX (6) byte string, NOT 2 bytes of data
    async signMessage(message) {
        if (typeof message === 'string') {
            message = strings_1.toUtf8Bytes(message);
        }
        const sig = await this.relayer.sign({
            message: bytes_1.hexlify(message),
        });
        return bytes_1.joinSignature(sig);
    }
    // Signs a transaction and returns the fully serialized, signed transaction.
    // The EXACT transaction MUST be signed, and NO additional properties to be added.
    // - This MAY throw if signing transactions is not supports, but if
    //   it does, sentTransaction MUST be overridden.
    async signTransaction(transaction) {
        throw new Error('DefenderRelaySigner#signTransaction: method not yet supported');
    }
    connect(provider) {
        return new DefenderRelaySigner(this.relayerCredentials, provider, this.options);
    }
    async sendTransaction(transaction) {
        var _a, _b;
        this._checkProvider('sendTransaction');
        const tx = await this.populateTransaction(transaction);
        if (!tx.gasLimit)
            throw new Error('DefenderRelaySigner#sendTransacton: relayer gas estimation not yet supported');
        const nonce = tx.nonce === undefined ? undefined : bignumber_1.BigNumber.from(tx.nonce).toNumber();
        let payloadGasParams;
        if (relayer_1.isLegacyTx(tx) && tx.gasPrice !== undefined) {
            payloadGasParams = {
                gasPrice: bytes_1.hexlify(tx.gasPrice),
            };
        }
        else if (relayer_1.isEIP1559Tx(tx) && tx.maxFeePerGas !== undefined && tx.maxPriorityFeePerGas !== undefined) {
            payloadGasParams = {
                maxFeePerGas: bytes_1.hexlify(tx.maxFeePerGas),
                maxPriorityFeePerGas: bytes_1.hexlify(tx.maxPriorityFeePerGas),
            };
        }
        const payload = {
            to: tx.to,
            gasLimit: bytes_1.hexlify(tx.gasLimit),
            data: tx.data ? bytes_1.hexlify(tx.data) : undefined,
            speed: tx.speed,
            value: tx.value ? bytes_1.hexlify(tx.value) : undefined,
            validUntil: tx.validUntil ? new Date(tx.validUntil).toISOString() : undefined,
            ...payloadGasParams,
        };
        const relayedTransaction = nonce
            ? await this.relayer.replaceTransactionByNonce(nonce, payload)
            : await this.relayer.sendTransaction(payload);
        let gasParams;
        if (relayer_1.isEIP1559Tx(relayedTransaction)) {
            gasParams = {
                maxFeePerGas: bignumber_1.BigNumber.from(relayedTransaction.maxFeePerGas),
                maxPriorityFeePerGas: bignumber_1.BigNumber.from(relayedTransaction.maxPriorityFeePerGas),
            };
        }
        else {
            gasParams = {
                gasPrice: bignumber_1.BigNumber.from(relayedTransaction.gasPrice),
            };
        }
        return this.provider._wrapTransaction({
            ...lodash_1.omit(relayedTransaction, 'gasPrice', 'maxPriorityFeePerGas', 'maxFeePerGas'),
            ...gasParams,
            gasLimit: bignumber_1.BigNumber.from(relayedTransaction.gasLimit),
            value: bignumber_1.BigNumber.from((_a = relayedTransaction.value) !== null && _a !== void 0 ? _a : 0),
            data: (_b = relayedTransaction.data) !== null && _b !== void 0 ? _b : '',
        }, relayedTransaction.hash);
    }
    // Adapted from ethers-io/ethers.js/packages/abstract-signer/src.ts/index.ts
    // Defender relay does not require all fields to be populated
    async populateTransaction(transaction) {
        const tx = await properties_1.resolveProperties(this.checkTransaction(transaction));
        if (tx.to != null) {
            tx.to = Promise.resolve(tx.to).then((to) => this.resolveName(to));
        }
        if (tx.gasLimit == null) {
            tx.gasLimit = this.estimateGas(tx).catch((error) => {
                return logger.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', logger_1.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                    error: error,
                    tx: tx,
                });
            });
        }
        if (!tx.speed && !tx.gasPrice && !tx.maxFeePerGas && !tx.maxPriorityFeePerGas) {
            if (this.options.gasPrice) {
                tx.gasPrice = this.options.gasPrice;
            }
            else if (this.options.maxFeePerGas && this.options.maxPriorityFeePerGas) {
                tx.maxFeePerGas = this.options.maxFeePerGas;
                tx.maxPriorityFeePerGas = this.options.maxPriorityFeePerGas;
            }
            else if (this.options.speed) {
                tx.speed = this.options.speed;
            }
        }
        if (!tx.validUntil && this.options.validForSeconds) {
            tx.validUntil = new Date(Date.now() + this.options.validForSeconds * 1000);
        }
        return await properties_1.resolveProperties(tx);
    }
    // Adapted from ethers-io/ethers.js/packages/abstract-signer/src.ts/index.ts
    // Defender relay accepts more transaction keys
    checkTransaction(transaction) {
        for (const key in transaction) {
            if (allowedTransactionKeys.indexOf(key) === -1) {
                logger.throwArgumentError('invalid transaction key: ' + key, 'transaction', transaction);
            }
        }
        const tx = properties_1.shallowCopy(transaction);
        tx.from = Promise.all([Promise.resolve(tx.from), this.getAddress()]).then((result) => {
            if (!!result[0] && result[0].toLowerCase() !== result[1].toLowerCase()) {
                logger.throwArgumentError('from address mismatch', 'transaction', transaction);
            }
            return result[1];
        });
        return tx;
    }
    /**
     * Signs the typed data value with types data structure for domain using the EIP-712 specification.
     * https://eips.ethereum.org/EIPS/eip-712
     *
     * @param domain EIP712Domain containing name, version, chainId, verifyingContract and salt. All optional
     * @param types set of all types encompassed by struct
     * @param value typed data to sign matching provided types
     * @returns typed data signature
     */
    async _signTypedData(domain, types, value) {
        const domainSeparator = hash_1._TypedDataEncoder.hashDomain(domain);
        const hashStructMessage = hash_1._TypedDataEncoder.from(types).hash(value);
        const sig = await this.relayer.signTypedData({
            domainSeparator: bytes_1.hexlify(domainSeparator),
            hashStructMessage: bytes_1.hexlify(hashStructMessage),
        });
        return bytes_1.joinSignature(sig);
    }
}
exports.DefenderRelaySigner = DefenderRelaySigner;
