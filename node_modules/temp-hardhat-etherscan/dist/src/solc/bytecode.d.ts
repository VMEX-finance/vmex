import { Artifacts } from "hardhat/types";
import { InferralType } from "./version";
declare type BytecodeComparison = {
    match: false;
} | {
    match: true;
    contractInformation: BytecodeExtractedData;
};
interface BytecodeExtractedData {
    immutableValues: ImmutableValues;
    libraryLinks: ResolvedLinks;
    normalizedBytecode: string;
}
interface ResolvedLinks {
    [sourceName: string]: {
        [libraryName: string]: string;
    };
}
interface ImmutableValues {
    [key: string]: string;
}
interface CompilerOutputBytecode {
    object: string;
    opcodes: string;
    sourceMap: string;
    linkReferences: {
        [sourceName: string]: {
            [libraryName: string]: Array<{
                start: 0;
                length: 20;
            }>;
        };
    };
    immutableReferences?: {
        [key: string]: Array<{
            start: number;
            length: number;
        }>;
    };
}
export declare function lookupMatchingBytecode(artifacts: Artifacts, matchingVersions: string[], deployedBytecode: string, inferralType: InferralType): Promise<{
    compilerInput: import("hardhat/types").CompilerInput;
    solcVersion: string;
    immutableValues: ImmutableValues;
    libraryLinks: ResolvedLinks;
    normalizedBytecode: string;
    sourceName: string;
    contractName: string;
    contract: {
        abi: any;
        evm: {
            bytecode: import("hardhat/types").CompilerOutputBytecode;
            deployedBytecode: import("hardhat/types").CompilerOutputBytecode;
            methodIdentifiers: {
                [methodSignature: string]: string;
            };
        };
    };
}[]>;
export declare function compareBytecode(deployedBytecode: string, runtimeBytecodeSymbols: CompilerOutputBytecode, inferralType: InferralType): Promise<BytecodeComparison>;
export declare function normalizeBytecode(bytecode: string, symbols: CompilerOutputBytecode): Promise<{
    libraryLinks: ResolvedLinks;
    immutableValues: ImmutableValues;
    normalizedBytecode: string;
}>;
export declare function zeroOutSlices(code: string, slices: Array<{
    start: number;
    length: number;
}>): string;
export {};
//# sourceMappingURL=bytecode.d.ts.map